"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class GlpiAPI {
    constructor(socket) {
        this.socket = socket;
    }
    getHttpSocket() {
        return this.socket.getHttp();
    }
    getSocket() {
        return this.socket;
    }
    setSocket(socket) {
        this.socket = socket;
    }
    setReloginInterceptor(interceptor) {
        this.reloginInterceptor = interceptor;
    }
    killSession() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = this.socket.call('GET', 'killSession');
            if (this.reloginInterceptor) {
                this.getHttpSocket().interceptors.request.eject(this.reloginInterceptor);
            }
            return response;
        });
    }
    lostPassword(email, passwordForgetToken, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                email,
            };
            if (password) {
                body.password_forget_token = passwordForgetToken;
                body.password = password;
            }
            return this.socket.call('PUT', 'lostPassword', { data: body });
        });
    }
    getMyProfiles() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('GET', 'getMyProfiles');
        });
    }
    getActiveProfile() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('GET', 'getActiveProfile');
        });
    }
    changeActiveProfile(profiles_id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('POST', 'changeActiveProfile', { data: { profiles_id } });
        });
    }
    getMyEntities(is_recursive = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('GET', 'getMyEntities', { params: { is_recursive } });
        });
    }
    getActiveEntities() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('GET', 'getActiveEntities');
        });
    }
    changeActiveEntities(entities_id = 'all', is_recursive = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('POST', 'changeActiveEntities', {
                data: {
                    entities_id,
                    is_recursive,
                },
            });
        });
    }
    getFullSession() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('GET', 'getFullSession');
        });
    }
    getGlpiConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('GET', 'getGlpiConfig');
        });
    }
    getItem(item_type, id, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('GET', `${item_type}/${id}`, { params: options });
        });
    }
    getItems(item_type, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializedParams = this.serializeObjectForGetMethod(['searchText'], options);
            return this.socket.call('GET', item_type, { params: serializedParams });
        });
    }
    getSubitems(item_type, id, subitem_type, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializedParams = this.serializeObjectForGetMethod(['searchText'], options);
            return this.socket.call('GET', `${item_type}/${id}/${subitem_type}`, {
                params: serializedParams,
            });
        });
    }
    getMultipleItems(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializedParams = this.serializeArrayForGetMethod(['items'], options);
            return this.socket.call('GET', 'getMultipleItems', { params: serializedParams });
        });
    }
    listSearchOptions(item_type, raw) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {};
            if (raw)
                params.raw = raw;
            return this.socket.call('GET', `listSearchOptions/${item_type}`, { params });
        });
    }
    search(item_type, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializedParams = this.serializeArrayForGetMethod(['criteria', 'forcedisplay'], options);
            return this.socket.call('GET', `search/${item_type}`, { params: serializedParams });
        });
    }
    addItem(item_type, input = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('POST', item_type, { data: { input } });
        });
    }
    updateItem(item_type, id, input = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.call('PUT', `${item_type}/${id}`, { data: { input } });
        });
    }
    deleteItem(item_type, id, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(id)) {
                const params = Object.assign({
                    input: id.map(i => ({ id: i })),
                }, options);
                return this.socket.call('DELETE', item_type, { params });
            }
            else {
                return this.socket.call('DELETE', `${item_type}/${id}`, { params: options });
            }
        });
    }
    serializeArrayForGetMethod(originalKeys, options) {
        const serializedOptions = Object.assign({}, options);
        for (const originalKey of originalKeys) {
            if (!options[originalKey] || !Array.isArray(options[originalKey]))
                continue;
            const arr = options[originalKey];
            for (let index = 0; index < arr.length; index++) {
                const item = arr[index];
                if (typeof item !== 'object') {
                    const serializedKey = `${originalKey}[${index}]`;
                    serializedOptions[serializedKey] = item;
                }
                else {
                    const keys = Object.keys(item);
                    for (const key of keys) {
                        if (Array.isArray(item[key])) {
                            const newObj = { [key]: item[key] };
                            const serializedSubitem = this.serializeArrayForGetMethod([key], newObj);
                            const subkeys = Object.keys(serializedSubitem);
                            for (const subkey of subkeys) {
                                const newKey = `${originalKey}[${index}][${key}]${subkey.replace(originalKey, '')}`;
                                serializedOptions[newKey] = serializedSubitem[subkey];
                            }
                        }
                        else {
                            const serializedKey = `${originalKey}[${index}][${key}]`;
                            serializedOptions[serializedKey] = item[key];
                        }
                    }
                }
            }
            delete serializedOptions[originalKey];
        }
        return serializedOptions;
    }
    serializeObjectForGetMethod(originalKeys, options) {
        const serializedOptions = Object.assign({}, options);
        for (const originalKey of originalKeys) {
            if (typeof options[originalKey] !== 'object')
                continue;
            const subkeys = Object.keys(options[originalKey]);
            for (const subkey of subkeys) {
                const newKey = `${originalKey}[${subkey}]`;
                serializedOptions[newKey] = options[originalKey][subkey];
            }
            delete serializedOptions[originalKey];
        }
        return serializedOptions;
    }
}
exports.GlpiAPI = GlpiAPI;
